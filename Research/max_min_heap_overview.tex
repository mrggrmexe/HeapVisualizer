\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{lmodern}
\usepackage{geometry}
\geometry{margin=2.5cm}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{mathtools}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{arrows.meta, positioning}
\usepackage[most]{tcolorbox}
\usepackage{xcolor}
\usepackage{listings}
\definecolor{codebg}{rgb}{0.95, 0.95, 0.98}
\definecolor{defbg}{rgb}{0.9, 0.97, 0.9}
\definecolor{notebg}{rgb}{0.93, 0.93, 0.99}

\newtcolorbox{defbox}[1]{
  colback=defbg,
  colframe=green!50!black,
  title=#1,
  sharp corners,
  boxrule=0.5pt,
  fonttitle=\bfseries
}

\newtcolorbox{notebox}{
  colback=notebg,
  colframe=blue!50!white,
  sharp corners,
  boxrule=0.5pt
}

\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  urlcolor=blue,
  citecolor=blue
}

\title{Бинарная куча min/max: теория, операции и псевдокод}
\author{}
\date{\today}

\begin{document}

\maketitle

\tableofcontents
\vspace{1cm}

\section{Определение}

\begin{defbox}{Определение}
\textbf{Бинарная куча} (heap) --- это полное бинарное дерево, удовлетворяющее \emph{кучному инварианту}. Различают два варианта:
\begin{itemize}[noitemsep, topsep=2pt]
  \item \textbf{Min-куча} (min-heap): ключ в любой вершине не превосходит ключей её потомков.
  \item \textbf{Max-куча} (max-heap): ключ в любой вершине не меньше ключей её потомков.
\end{itemize}
\end{defbox}

Полнота означает, что дерево заполняется уровнями слева направо без ``дырок''. Благодаря этому кучу удобно хранить в массиве.

\section{Представление в массиве}

Пусть массив $A$ хранит вершины по уровням (корень --- в $A[1]$). Тогда индексация такова:
\begin{align*}
\text{left}(i) &= 2i, & \text{right}(i) &= 2i + 1, & \text{parent}(i) &= \left\lfloor \frac{i}{2} \right\rfloor.
\end{align*}
Размер актуальной кучи обозначим $n$ (первые $n$ элементов массива). Такая раскладка обеспечивает $O(1)$ доступ к родителю/детям и занимает $O(n)$ памяти.

\begin{notebox}
\textbf{Важно:} Во многих языках программирования (C++, Python, Java) принята индексация с \textbf{нуля}. В этом случае формулы меняются:
\[
\text{left}(i) = 2i + 1, \quad \text{right}(i) = 2i + 2, \quad \text{parent}(i) = \left\lfloor \frac{i-1}{2} \right\rfloor.
\]
\end{notebox}

\section{Базовые операции и сложности}

\begin{center}
\begin{tabular}{@{}lcc@{}}
\toprule
Операция & Min-куча & Max-куча \\
\midrule
\texttt{Extremum()} (минимум/максимум, чтение корня) & $O(1)$ & $O(1)$ \\
\texttt{Insert(x)} & $O(\log n)$ & $O(\log n)$ \\
\texttt{ExtractExtremum()} (удаление корня) & $O(\log n)$ & $O(\log n)$ \\
\texttt{DecreaseKey(i,\Delta)} / \texttt{IncreaseKey(i,\Delta)} & $O(\log n)$ & $O(\log n)$ \\
\texttt{Delete(i)} & $O(\log n)$ & $O(\log n)$ \\
\texttt{BuildHeap(A)} (из неупорядоченного массива) & $O(n)$ & $O(n)$ \\
\texttt{HeapSort(A)} & $O(n\log n)$ & $O(n\log n)$ \\
\bottomrule
\end{tabular}
\end{center}

\paragraph{Идея подъёма/спуска.} Для восстановления инварианта применяются две примитивные процедуры:
\begin{itemize}[noitemsep, topsep=2pt]
  \item \texttt{SiftUp(i)} (Просеивание вверх) --- сравнение с родителем и подъём узла вверх.
  \item \texttt{SiftDown(i)} (Просеивание вниз) --- сравнение с лучшим потомком и спуск узла вниз.
\end{itemize}
В полном бинарном дереве высота $\Theta(\log n)$, отсюда асимптотики.

\section{Псевдокод для min-кучи}

Ниже приведён типичный вариант на массиве $A[1..n]$. Замены \texttt{<} на \texttt{>} дают max-кучу.

\begin{algorithm}[H]
\caption{\texttt{SiftUp}(i) для min-кучи}
\begin{algorithmic}[1]
\While{$i>1$ \textbf{and} $A[i] < A[\lfloor i/2 \rfloor]$}
  \State \textsc{Swap} $A[i]$ и $A[\lfloor i/2 \rfloor]$
  \State $i \gets \lfloor i/2 \rfloor$
\EndWhile
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{\texttt{SiftDown}(i) для min-кучи}
\begin{algorithmic}[1]
\While{true}
  \State $l \gets 2i$, $r \gets 2i+1$, $m \gets i$
  \If{$l \le n$ \textbf{and} $A[l] < A[m]$} \State $m \gets l$ \EndIf
  \If{$r \le n$ \textbf{and} $A[r] < A[m]$} \State $m \gets r$ \EndIf
  \If{$m = i$} \State \textbf{break} \EndIf
  \State \textsc{Swap} $A[i]$ и $A[m]$
  \State $i \gets m$
\EndWhile
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{\texttt{Insert}(x)}
\begin{algorithmic}[1]
\State $n \gets n+1$
\State $A[n] \gets x$
\State \texttt{SiftUp}$(n)$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{\texttt{GetMin}()}
\begin{algorithmic}[1]
\State \textbf{return} $A[1]$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{\texttt{ExtractMin}()}
\begin{algorithmic}[1]
\State $ans \gets A[1]$
\State $A[1] \gets A[n]$
\State $n \gets n-1$
\State \texttt{SiftDown}$(1)$
\State \textbf{return} $ans$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{\texttt{DecreaseKey}(i, \Delta)}
\begin{algorithmic}[1]
\State $A[i] \gets A[i] - \Delta$ \Comment{$\Delta>0$}
\State \texttt{SiftUp}$(i)$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{\texttt{BuildMinHeap}(A)}
\begin{algorithmic}[1]
\State $n \gets |A|$
\For{$i \gets \lfloor n/2 \rfloor$ \textbf{down to} $1$}
  \State \texttt{SiftDown}$(i)$
\EndFor
\end{algorithmic}
\end{algorithm}

\paragraph{Max-куча.} Для max-кучи сравнения меняются на противоположные (\texttt{<} $\leftrightarrow$ \texttt{>}), имена процедур --- \texttt{GetMax}, \texttt{ExtractMax}, \texttt{IncreaseKey} и т.п.

\section{Сортировка кучей (HeapSort)}

\textbf{Вариант 1 (через max-кучу).}
\begin{enumerate}[noitemsep, topsep=2pt]
  \item Построить max-кучу за $O(n)$.
  \item Повторять $n$ раз: обменять $A[1]$ и $A[n]$, уменьшить $n$, выполнить \texttt{SiftDown(1)}.
\end{enumerate}
Получаем неубывающую сортировку за $O(n\log n)$, \emph{in-place} и без дополнительной памяти (кроме $O(1)$). Алгоритм неустойчив.

\begin{algorithm}[H]
\caption{\texttt{HeapSort}(A)}
\begin{algorithmic}[1]
\State $n \gets |A|$
\State \texttt{BuildMaxHeap}$(A)$ \Comment{Использует \texttt{SiftDown} с обратными сравнениями}
\For{$i \gets n$ \textbf{down to} $2$}
  \State \textsc{Swap} $A[1]$ и $A[i]$
  \State $n \gets n - 1$
  \State \texttt{SiftDown}$(1)$ \Comment{На куче размера $n-1$}
\EndFor
\end{algorithmic}
\end{algorithm}

\section{Почему \texttt{BuildHeap} работает за $O(n)$}

Элементы на глубине $h$ могут опуститься вниз не более чем на $h$ уровней. Число вершин на глубине $h$ около $n/2^{h+1}$. Суммарная сложность
\[
\sum_{h\ge 0} \frac{n}{2^{h+1}} \cdot h = O(n).
\]
Интуитивно: большая часть вершин --- листья или почти листья; их спуск короткий, что и даёт линейное время.

\section{Пример работы с min-кучей}

Рассмотрим последовательность операций для min-кучи. Исходно куча пуста: $A = [\,]$, $n=0$.

\begin{enumerate}
  \item \texttt{Insert(5)}: $A = [5]$
  \item \texttt{Insert(3)}: $A = [3, 5]$ (после \texttt{SiftUp})
  \item \texttt{Insert(8)}: $A = [3, 5, 8]$
  \item \texttt{Insert(1)}: $A = [1, 3, 8, 5]$ (после \texttt{SiftUp})
  \item \texttt{GetMin()}: возвращает $1$
  \item \texttt{ExtractMin()}: 
    \begin{itemize}
      \item Возвращает $1$
      \item $A[1] = A[4] = 5$, $n=3$, $A = [5, 3, 8]$
      \item \texttt{SiftDown(1)}: $A = [3, 5, 8]$
    \end{itemize}
\end{enumerate}

\section{Наглядный пример (min-куча)}

\begin{center}
\begin{tikzpicture}[level distance=1.2cm,
  every node/.style={circle,draw,minimum size=6mm,inner sep=0pt},
  level 1/.style={sibling distance=34mm},
  level 2/.style={sibling distance=18mm}]
\node{2}
  child { node {5}
    child { node {9} }
    child { node {7} } }
  child { node {3}
    child { node {8} }
    child { node {10} } };
\end{tikzpicture}
\end{center}

Этот рисунок соответствует массиву $A = [\,2,\,5,\,3,\,9,\,7,\,8,\,10\,]$ (индексация с 1). Видно, что каждый родитель не больше своих детей.

\section{Практические заметки по реализации}

\begin{itemize}[noitemsep, topsep=2pt]
  \item Индексация с нуля удобна в языках C/C++/Python. Тогда формулы: \texttt{left(i)=2i+1}, \texttt{right(i)=2i+2}, \texttt{parent(i)=(i-1)/2}.
  \item При равных ключах стоит определиться с политикой стабильности и направлением сравнения, чтобы поведение было детерминированным.
  \item Для структур с часто изменяемым приоритетом используйте \texttt{DecreaseKey}/\texttt{IncreaseKey} и храните обратные индексы (\emph{handles}) к позициям в куче.
  \item Вставки пачкой быстрее делать через \texttt{BuildHeap}, а не последовательными \texttt{Insert}.
  \item \textbf{Сложность по памяти:} $O(n)$ для хранения массива элементов.
\end{itemize}

\section{Краткая сводка различий min- и max-кучи}

\begin{itemize}[noitemsep, topsep=2pt]
  \item \textbf{Инвариант:} \; \texttt{min:} $parent \le child$; \; \texttt{max:} $parent \ge child$.
  \item \textbf{Экстремум:} \; \texttt{min:} корень --- минимум; \; \texttt{max:} корень --- максимум.
  \item \textbf{Остальные операции:} идентичны по структуре, меняется лишь знак сравнения.
\end{itemize}

\vfill

\end{document}